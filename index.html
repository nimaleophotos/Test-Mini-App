<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Phone Multi‑Lens Camera (Super-wide / Wide / Normal)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;padding:16px;background:#f7f7fb;color:#111}
    header{display:flex;gap:12px;align-items:center}
    button{padding:8px 12px;border-radius:8px;border:1px solid #ddd;background:white}
    #videoWrap{margin-top:12px;display:grid;grid-template-columns:1fr 220px;gap:12px}
    video{width:100%;height:auto;border-radius:12px;background:#000}
    .controls{display:flex;flex-direction:column;gap:8px}
    select{padding:8px;border-radius:8px}
    .hint{font-size:13px;color:#555}
    .badge{font-size:12px;padding:4px 8px;background:#222;color:#fff;border-radius:999px}
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0;font-size:18px">Phone Multi‑Lens Camera</h1>
    <div class="badge">iOS & Android: uses deviceId / labels</div>
  </header>

  <p class="hint">This demo tries to select the phone's multiple back cameras (super-wide, wide, normal) by using the list of video input devices. On iOS Safari and modern Chrome/Android the camera device labels often include words like "ultra", "wide", "tele", "main" after you grant permission.</p>

  <div id="videoWrap">
    <div>
      <video id="preview" autoplay playsinline muted></video>
    </div>
    <div class="controls">
      <label>Available cameras
        <select id="deviceSelect"></select>
      </label>

      <div>
        <button id="btnSuper">Super‑wide</button>
        <button id="btnWide">Wide</button>
        <button id="btnNormal">Normal</button>
      </div>

      <div>
        <button id="btnToggleFacing">Toggle front/back</button>
      </div>

      <div>
        <button id="btnCapture">Capture photo</button>
      </div>

      <div class="hint">Captured image:</div>
      <canvas id="photoCanvas" width="640" height="480" style="width:100%;border-radius:8px;background:#eee"></canvas>
    </div>
  </div>

  <script>
    // Heuristics to match device labels to the lens types.
    const LENS_KEYWORDS = {
      super: ['ultra', 'super', 'ultrawide', 'ultra-wide', 'superwide', 'fisheye'],
      wide:  ['wide', 'main', 'back', 'wide-angle', 'wideangle'],
      normal:['tele', 'normal', 'standard', 'primary', 'main'] // 'tele' can be a proxy for normal/tele depending on device
    };

    const video = document.getElementById('preview');
    const deviceSelect = document.getElementById('deviceSelect');
    const photoCanvas = document.getElementById('photoCanvas');
    let currentStream = null;
    let devices = [];
    let lastFacing = 'environment'; // 'user' or 'environment'

    async function ensurePermissions() {
      // Request permission early so device labels become available (especially on iOS/Chrome).
      try {
        const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        stopStream(s);
      } catch (e) {
        console.warn('Permission request failed or denied:', e);
      }
    }

    function stopStream(stream) {
      if (!stream) return;
      const tracks = stream.getTracks();
      tracks.forEach(t => t.stop());
    }

    async function enumerateCameras() {
      const list = await navigator.mediaDevices.enumerateDevices();
      devices = list.filter(d => d.kind === 'videoinput');
      deviceSelect.innerHTML = '';
      devices.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i+1}`;
        deviceSelect.appendChild(opt);
      });
    }

    // Choose deviceId by matching label keywords. Returns deviceId or null.
    function chooseDeviceIdForLens(lensType) {
      const keywords = LENS_KEYWORDS[lensType] || [];
      // first try strict label match, case-insensitive
      for (const d of devices) {
        if (!d.label) continue;
        const lower = d.label.toLowerCase();
        for (const kw of keywords) if (lower.includes(kw)) return d.deviceId;
      }
      // fallback heuristics: if only 2 cameras, pick the second for "super" or "wide"
      if (devices.length === 1) return devices[0].deviceId;
      if (devices.length === 2) {
        if (lensType === 'normal') return devices[0].deviceId;
        return devices[1].deviceId;
      }
      // fallback: return distinct cameras by index: map lensType->index
      const order = {super: 0, wide: 1, normal: 2};
      const idx = order[lensType] || 0;
      if (devices[idx]) return devices[idx].deviceId;
      return devices[0] ? devices[0].deviceId : null;
    }

    async function startStreamWithDevice(deviceId, extraConstraints = {}) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('getUserMedia not supported in this browser.');
        return;
      }
      if (currentStream) stopStream(currentStream);
      const constraints = { video: { deviceId: deviceId ? { exact: deviceId } : undefined, ...extraConstraints }, audio: false };
      try {
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        // try to read capabilities (zoom etc)
        const track = currentStream.getVideoTracks()[0];
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        console.log('Track capabilities', caps);
      } catch (err) {
        console.error('Could not start stream:', err);
        alert('Could not start camera with that lens. See console for details.');
      }
    }

    async function trySelectLens(lensType) {
      // If labels are present, we try to match them. Otherwise try facingMode + heuristics.
      let deviceId = chooseDeviceIdForLens(lensType);
      if (deviceId) return startStreamWithDevice(deviceId);

      // no deviceId chosen: fallback to facingMode and ideal width/height which may bias the camera
      const fallbackConstraints = { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: lastFacing };
      return startStreamWithDevice(null, fallbackConstraints);
    }

    // UI wiring
    document.getElementById('btnSuper').addEventListener('click', () => trySelectLens('super'));
    document.getElementById('btnWide').addEventListener('click', () => trySelectLens('wide'));
    document.getElementById('btnNormal').addEventListener('click', () => trySelectLens('normal'));

    deviceSelect.addEventListener('change', async (e) => {
      await startStreamWithDevice(e.target.value);
    });

    document.getElementById('btnToggleFacing').addEventListener('click', async () => {
      lastFacing = lastFacing === 'environment' ? 'user' : 'environment';
      // try to start with facingMode constraint -- deviceId may change per facing
      await startStreamWithDevice(null, { facingMode: lastFacing });
    });

    document.getElementById('btnCapture').addEventListener('click', () => {
      const ctx = photoCanvas.getContext('2d');
      const w = photoCanvas.width = video.videoWidth || 640;
      const h = photoCanvas.height = video.videoHeight || 480;
      ctx.drawImage(video, 0, 0, w, h);
    });

    // On load: request permission, then enumerate devices and start the default back camera.
    (async function init(){
      await ensurePermissions();
      await enumerateCameras();

      // Try to auto-start 'wide' (common default). If none, start whatever is available.
      const preferred = chooseDeviceIdForLens('wide') || chooseDeviceIdForLens('normal') || (devices[0] && devices[0].deviceId);
      if (preferred) {
        deviceSelect.value = preferred;
        startStreamWithDevice(preferred);
      } else {
        // final fallback: facingMode environment
        startStreamWithDevice(null, { facingMode: 'environment' });
      }

      // Re-enumerate on devicechange (e.g., plugging in external camera)
      navigator.mediaDevices.addEventListener('devicechange', async () => {
        await enumerateCameras();
      });
    })();

    // Notes for developers (shown in console):
    console.info(`Notes:\n - Labels for devices are empty until a getUserMedia permission is granted in many browsers (iOS/Android).\n - device.label often contains words like 'ultra', 'wide', 'tele' on phones; we use heuristics to match them.\n - Some browsers expose track.getCapabilities() including zoom, torch, and focusDistance. You can call applyConstraints on the track to adjust zoom if supported.\n - There's no cross-browser standardized 'lens type' property yet; rely on device labels and ordering as best effort.`);
  </script>
</body>
</html>
