<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Camera</title>
  <style>
    body { margin:0; font-family:sans-serif; background:#000; color:white; overflow:hidden; }
    #camera { position:relative; width:100%; height:100vh; display:flex; justify-content:center; align-items:center; background:black; }
    video { width:100%; height:100%; object-fit:cover; }
    .overlay.grid { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;
      background-image: linear-gradient(rgba(255,255,255,.2) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,.2) 1px, transparent 1px);
      background-size: 33.3% 33.3%; display:none; }
    .controls { position:absolute; bottom:20px; width:100%; display:flex; justify-content:center; gap:12px; }
    button { background:rgba(0,0,0,.6); border:none; color:white; border-radius:50%; width:60px; height:60px; font-size:14px; }
    .lens { position:absolute; top:20px; width:100%; display:flex; justify-content:center; gap:10px; }
    .lens button { width:50px; height:50px; border-radius:50%; }
  </style>
</head>
<body>
  <div id="camera">
    <video id="preview" autoplay playsinline></video>
    <div id="grid" class="overlay grid"></div>
    <div class="lens">
      <button onclick="setZoom(0.5)">0.5x</button>
      <button onclick="setZoom(1)">1x</button>
      <button onclick="setZoom(2)">2x</button>
    </div>
    <div class="controls">
      <button onclick="toggleTorch()">âš¡</button>
      <button onclick="capture()">ðŸ“¸</button>
      <button onclick="toggleGrid()">#</button>
      <button onclick="toggleAspect()">â‡†</button>
    </div>
  </div>
  <canvas id="snap" style="display:none"></canvas>

  <script>
    let stream, track;
    let currentAspect = "cover"; // cover, contain, 1:1

    async function initCamera() {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }
      });
      const video = document.getElementById("preview");
      video.srcObject = stream;
      track = stream.getVideoTracks()[0];
    }

    async function setZoom(level) {
      if (!track) return;
      const caps = track.getCapabilities();
      if ("zoom" in caps) {
        const clamped = Math.min(caps.zoom.max, Math.max(caps.zoom.min, level));
        await track.applyConstraints({ advanced: [{ zoom: clamped }] });
      } else {
        alert("Zoom not supported");
      }
    }

    async function toggleTorch() {
      if (!track) return;
      const caps = track.getCapabilities();
      if ("torch" in caps) {
        const settings = track.getSettings();
        const torchOn = settings.torch === true;
        await track.applyConstraints({ advanced: [{ torch: !torchOn }] });
      } else {
        alert("Flash not supported");
      }
    }

    function toggleGrid() {
      const grid = document.getElementById("grid");
      grid.style.display = grid.style.display === "block" ? "none" : "block";
    }

    function toggleAspect() {
      const video = document.getElementById("preview");
      if (currentAspect === "cover") {
        video.style.objectFit = "contain";
        currentAspect = "contain";
      } else if (currentAspect === "contain") {
        video.style.objectFit = "cover";
        video.style.aspectRatio = "1 / 1";
        currentAspect = "1:1";
      } else {
        video.style.objectFit = "cover";
        video.style.aspectRatio = "";
        currentAspect = "cover";
      }
    }

    function capture() {
      const video = document.getElementById("preview");
      const canvas = document.getElementById("snap");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const url = canvas.toDataURL("image/jpeg");
      window.open(url, "_blank");
    }

    initCamera();
  </script>
</body>
</html>
